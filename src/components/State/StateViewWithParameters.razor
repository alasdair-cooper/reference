@using System.ComponentModel
@using Microsoft.Extensions.Logging
@using Microsoft.Extensions.Options

@typeparam TParameters
@typeparam T

<ErrorBoundary>
    <ChildContent>
        @if (Policy is not null || Roles is not null || Resource is not null)
        {
            <AuthorizeView
                Policy="@Policy"
                Roles="@Roles"
                Resource="@Resource">
                <Authorized>
                    @RenderState(State)
                </Authorized>
                <Authorizing>
                    @RenderLoading(new LoadingState())
                </Authorizing>
                <NotAuthorized>
                    @RenderUnauthorized(context)
                </NotAuthorized>
            </AuthorizeView>
        }
        else
        {
            @RenderState(State)
        }
    </ChildContent>
    <ErrorContent>
        @RenderError(new ErrorState(context))
    </ErrorContent>
</ErrorBoundary>

@code {
    private readonly ILogger<StateViewWithParameters<TParameters, T>> _logger;

    private bool _hasLoadedAtLeastOnce;

    protected State? State;

    protected readonly RenderFragment<State?> RenderState;
    protected readonly RenderFragment<ErrorState> RenderError;
    protected readonly RenderFragment<AuthenticationState> RenderUnauthorized;
    protected readonly RenderFragment<LoadingState> RenderLoading;

    public StateViewWithParameters(IOptions<StateOptions> stateOptions, ILogger<StateViewWithParameters<TParameters, T>> logger)
    {
        _logger = logger;

        RenderError = x => ErrorContent?.Invoke(x) ?? stateOptions.Value.DefaultErrorContent(x);
        RenderUnauthorized = x => UnauthorizedContent?.Invoke(new UnauthorizedState(x.User, Resource, new AuthorizeData(Policy, Roles))) ?? stateOptions.Value.DefaultUnauthorizedContent(new UnauthorizedState(x.User, Resource, new AuthorizeData(Policy, Roles)));
        RenderLoading = x => LoadingContent?.Invoke(x) ?? stateOptions.Value.DefaultLoadingContent(x);

        RenderState =
            x =>
                x switch
                {
                    SuccessState<T> successState => SuccessContent?.Invoke(successState) ?? SuccessOrNotFoundContent?.Invoke(new SuccessOrNotFoundState<T>(successState.Value)) ?? ChildContent?.Invoke(successState) ?? throw new InvalidOperationException($"State view must have either {nameof(SuccessContent)}, {nameof(SuccessOrNotFoundContent)} or {nameof(ChildContent)} defined."),
                    NotFoundState notFound => SuccessOrNotFoundContent?.Invoke(new SuccessOrNotFoundState<T>(default)) ?? NotFoundContent?.Invoke(notFound) ?? stateOptions.Value.DefaultNotFoundContent(notFound),
                    ErrorState errorState => RenderError(errorState),
                    TimedOutState timedOutState => TimedOutContent?.Invoke(timedOutState) ?? stateOptions.Value.DefaultTimedOutContent(timedOutState),
                    LoadingState loadingState => RenderLoading(loadingState),
                    _ => RenderLoading(new LoadingState())
                };
    }

    [Parameter]
    [EditorRequired]
    public required StateStore<TParameters, T> Store { get; set; }

    [Parameter]
    public TParameters Parameters
    {
        get;
        set
        {
            if (!ShouldRun()) return;

            // If the parameter type implements `INotifyPropertyChanged`, only run the setter once
            if (_hasLoadedAtLeastOnce && field is INotifyPropertyChanged) return;

            _hasLoadedAtLeastOnce = true;
            field = value;
            LoadStoreWithStateHandler(field);

            // Parameters implementing `INotifyPropertyChanged` trigger state reloading themselves 
            if (field is INotifyPropertyChanged notifyPropertyChanged)
            {
                notifyPropertyChanged.PropertyChanged +=
                    (@object, _) =>
                    {
                        field = (TParameters)@object!;
                        LoadStoreWithStateHandler(field);
                    };
            }

            return;

            bool ShouldRun()
            {
                // Always set the parameter value the first time the setter is called
                if (!_hasLoadedAtLeastOnce)
                {
                    return true;
                }

                switch (value, field)
                {
                    case (null, null):
                        return false;
                    case (null, not null) or (not null, null):
                        return true;
                    case (IEquatable<TParameters> a, IEquatable<TParameters> b):
                        return !a.Equals(b);
                    default:
                        _logger.LogWarning($"State views with reference type parameters reload more frequently than necessary. Consider implementing {nameof(IEquatable<>)} or {nameof(INotifyPropertyChanged)} for {nameof(TParameters)}.");
                        // Reference types always trigger the value to be updated as there is no way to tell if there's been a change or not
                        return true;
                }
            }
        }
    } = default!;

    [Parameter]
    public RenderFragment<SuccessState<T>>? ChildContent { get; set; }

    [Parameter]
    public RenderFragment<SuccessState<T>>? SuccessContent { get; set; }

    [Parameter]
    public RenderFragment<SuccessOrNotFoundState<T>>? SuccessOrNotFoundContent { get; set; }

    [Parameter]
    public RenderFragment<LoadingState>? LoadingContent { get; set; }

    [Parameter]
    public RenderFragment<TimedOutState>? TimedOutContent { get; set; }

    [Parameter]
    public RenderFragment<ErrorState>? ErrorContent { get; set; }

    [Parameter]
    public RenderFragment<NotFoundState>? NotFoundContent { get; set; }

    [Parameter]
    public RenderFragment<UnauthorizedState>? UnauthorizedContent { get; set; }

    [Parameter]
    public string? Policy { get; set; }

    [Parameter]
    public string? Roles { get; set; }

    [Parameter]
    public object? Resource { get; set; }

    protected void LoadStoreWithStateHandler(TParameters parameters)
    {
        Store.StateChanged -= OnStateChanged;
        Store.StateChanged += OnStateChanged;
        _ = Store.LoadAsync(parameters);

        return;

        void OnStateChanged(object? _, State state)
        {
            State = state;
            InvokeAsync(StateHasChanged);
        }
    }

}