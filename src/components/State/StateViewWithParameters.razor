@using System.Collections
@using System.Diagnostics
@using System.Diagnostics.CodeAnalysis
@using Microsoft.Extensions.Options

@typeparam TParameters
@typeparam T

@implements IStateView

<CascadingValue Value="@((IStateView)this)">
    <ErrorBoundary>
        <ChildContent>
            @if (Policy is not null || Roles is not null || Resource is not null)
            {
                <AuthorizeView
                    Policy="@Policy"
                    Roles="@Roles"
                    Resource="@Resource">
                    <Authorized>
                        @_renderState?.Invoke(State)
                    </Authorized>
                    <Authorizing>
                        @_renderLoading?.Invoke(LoadingStateViewData.FromState(Store.NewLoadingState(), _timeProvider.GetUtcNow(), LoadStoreWithStateHandler))
                    </Authorizing>
                    <NotAuthorized>
                        @_renderUnauthorized?.Invoke(new UnauthorizedStateViewData(context.User, Resource, new AuthorizeData(Policy, Roles), _timeProvider.GetUtcNow(), LoadStoreWithStateHandler))
                    </NotAuthorized>
                </AuthorizeView>
            }
            else
            {
                @_renderState?.Invoke(State)
            }
        </ChildContent>
        <ErrorContent>
            @_renderError?.Invoke(new ErrorStateViewData(context, _timeProvider.GetUtcNow(), LoadStoreWithStateHandler))
        </ErrorContent>
    </ErrorBoundary>
</CascadingValue>

@code {

    private readonly TimeProvider _timeProvider;

    private StateViewData? State { get; set; }

    private readonly RenderFragment<StateViewData?>? _renderState;
    private readonly RenderFragment<ErrorStateViewData>? _renderError;
    private readonly RenderFragment<UnauthorizedStateViewData>? _renderUnauthorized;
    private readonly RenderFragment<LoadingStateViewData>? _renderLoading;

    private bool _hasLoadedAtLeastOnce;

    private static readonly IEqualityComparer<TParameters> DefaultParametersEqualityComparer =
        EqualityComparer<TParameters>.Create(
            (a, b) =>
                (a, b) switch
                {
                    (IStructuralEquatable s1, IStructuralEquatable s2) => s1.Equals(s2, StructuralComparisons.StructuralEqualityComparer),
                    (IEquatable<TParameters> e1, IEquatable<TParameters> e2) => e1.Equals(e2),
                    _ => false
                });

    public StateViewWithParameters(TimeProvider timeProvider)
    {
        _timeProvider = timeProvider;

        _renderError = x => ErrorContent?.Invoke(x) ?? Options.Value.DefaultErrorContent?.Invoke(x) ?? StateDefaults.DefaultContent.Empty;
        _renderUnauthorized = x => UnauthorizedContent?.Invoke(x) ?? Options.Value.DefaultUnauthorizedContent?.Invoke(x) ?? StateDefaults.DefaultContent.Empty;
        _renderLoading = x => LoadingContent?.Invoke(x) ?? Options.Value.DefaultLoadingContent?.Invoke(x) ?? StateDefaults.DefaultContent.Empty;

        _renderState =
            x =>
                x switch
                {
                    SuccessStateViewData<T> successState => SuccessContent?.Invoke(successState) ?? SuccessOrNotFoundContent?.Invoke(new SuccessOrNotFoundStateViewData<T>(successState, null)) ?? ChildContent?.Invoke(successState) ?? throw new InvalidOperationException($"State view must have either {nameof(SuccessContent)}, {nameof(SuccessOrNotFoundContent)} or {nameof(ChildContent)} defined."),
                    NotFoundStateViewData notFound => SuccessOrNotFoundContent?.Invoke(new SuccessOrNotFoundStateViewData<T>(null, notFound)) ?? NotFoundContent?.Invoke(notFound) ?? Options.Value.DefaultNotFoundContent?.Invoke(notFound),
                    ErrorStateViewData errorState => _renderError(errorState),
                    TimedOutStateViewData timedOutState => TimedOutContent?.Invoke(timedOutState) ?? Options.Value.DefaultTimedOutContent?.Invoke(timedOutState),
                    LoadingStateViewData loadingState => _renderLoading(loadingState),
                    null => StateDefaults.DefaultContent.Empty,
                    _ => throw new UnreachableException()
                }
                ?? StateDefaults.DefaultContent.Empty;
    }

    public event EventHandler<TimeSpan>? StateLoadedSuccessfully;

    /// <summary>
    /// The state store for loading the state for this view.
    /// </summary>
    [Parameter]
    [EditorRequired]
    public required StateStore<TParameters, T> Store { get; set; }

    /// <summary>
    /// The parameters to the store.
    /// </summary>
    [Parameter]
    public TParameters Parameters
    {
        get;
        set
        {
            var comparer = ParametersEqualityComparer ?? DefaultParametersEqualityComparer;

            if (comparer.Equals(value, field)) return;

            field = value;

            if (_hasLoadedAtLeastOnce)
            {
                InvokeAsync(LoadStoreWithStateHandler);
            }
        }
    } = default!;

    /// <summary>
    /// This overrides the default equality comparer used to determine whether the <see cref="Parameters"/> have changed.
    /// </summary>
    /// <remarks>
    /// The default equality comparer is a custom comparer that caries out the following checks in order:
    /// <list type="number">
    /// <item>If <see cref="TParameters"/> implements <see cref="IStructuralEquatable"/>, then return the result of <see cref="IStructuralEquatable.Equals(object, IEqualityComparer)"/> using <see cref="StructuralComparisons.StructuralEqualityComparer"/>.</item>
    /// <item>If <see cref="TParameters"/> implements <see cref="IEquatable{TParameters}"/>, then return the result of <see cref="IEquatable{TParameters}.Equals(TParameters)"/>.</item>
    /// <item>Otherwise, the objects are treated as not equal (as it's a reference type and there is no way to know if it has actually changed or not).</item>
    /// </list>
    /// </remarks>
    [Parameter]
    public IEqualityComparer<TParameters>? ParametersEqualityComparer { get; set; }

    /// <summary>
    /// This content is rendered when the store loads successfully.
    /// </summary>
    [Parameter]
    public RenderFragment<SuccessStateViewData<T>>? ChildContent { get; set; }

    /// <summary>
    /// This content is rendered when the store loads successfully.
    /// </summary>
    [Parameter]
    public RenderFragment<SuccessStateViewData<T>>? SuccessContent { get; set; }

    /// <summary>
    /// This content is rendered when the store loads successfully or returned <see langword="null"/>.
    /// </summary>
    [Parameter]
    public RenderFragment<SuccessOrNotFoundStateViewData<T>>? SuccessOrNotFoundContent { get; set; }

    /// <summary>
    /// This content is rendered while the store is loading and while being authorized.
    /// </summary>
    [Parameter]
    public RenderFragment<LoadingStateViewData>? LoadingContent { get; set; }

    /// <summary>
    /// This content is rendered when the store loading times out.
    /// </summary>
    [Parameter]
    public RenderFragment<TimedOutStateViewData>? TimedOutContent { get; set; }

    /// <summary>
    /// This content is rendered when the store throws an exception or an exception was throw while rendering some other content.
    /// </summary>
    [Parameter]
    public RenderFragment<ErrorStateViewData>? ErrorContent { get; set; }

    /// <summary>
    /// This content is rendered when the store returns <see langword="null"/>.
    /// </summary>
    [Parameter]
    public RenderFragment<NotFoundStateViewData>? NotFoundContent { get; set; }

    /// <summary>
    /// This content is rendered when the user is unauthorized, based on <see cref="Roles"/>, <see cref="Policy"/> and <see cref="Resource"/>.
    /// </summary>
    [Parameter]
    public RenderFragment<UnauthorizedStateViewData>? UnauthorizedContent { get; set; }

    /// <summary>
    /// The policy name that determines whether the content can be displayed.
    /// </summary>
    [Parameter]
    public string? Policy { get; set; }

    /// <summary>
    /// A comma-delimited list of roles that are allowed to display the content.
    /// </summary>
    [Parameter]
    public string? Roles { get; set; }

    /// <summary>
    /// The resource to which access is being controlled.
    /// </summary>
    [Parameter]
    public object? Resource { get; set; }

    [Parameter]
    public Action<StateOptions>? ConfigureOptions { get; set; }

    /// <summary>
    /// The length of time before a loading state is considered to have timed out.
    /// </summary>
    [Parameter]
    public TimeSpan Timeout { get; set; }

    /// <summary>
    /// Disables all default content so that nothing is rendered by default.
    /// </summary>
    [Parameter]
    public bool IsDefaultContentDisabled { get; set; }

    /// <summary>
    /// This changes the lifecycle method from which the store is initially loaded.
    /// </summary>
    [Parameter]
    public StateInitialLoadEvent InitialLoadEvent { get; set; } = StateInitialLoadEvent.OnAfterRender;

    public IOptions<StateOptions> Options =>
        Store.CreateOptions(
            x =>
            {
                ConfigureOptions?.Invoke(x);
                x.Timeout = Timeout;

                if (IsDefaultContentDisabled)
                {
                    x.DisableDefaultContent();
                }
            });

    protected override void OnInitialized()
    {
        if (State is null && InitialLoadEvent is StateInitialLoadEvent.OnInitialized)
        {
            LoadStoreWithStateHandler();
        }
    }

    protected override void OnParametersSet()
    {
        if (InitialLoadEvent is StateInitialLoadEvent.OnParametersSet)
        {
            LoadStoreWithStateHandler();
        }
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && InitialLoadEvent is StateInitialLoadEvent.OnAfterRender)
        {
            LoadStoreWithStateHandler();
        }
    }

    private void LoadStoreWithStateHandler()
    {
        Store.StateChanged -= UpdateState;
        Store.StateChanged -= InvokeStateLoadedSuccessfully;

        Store.StateChanged += UpdateState;
        Store.StateChanged += InvokeStateLoadedSuccessfully;

        _ = Store.LoadAsync(Parameters);
        _hasLoadedAtLeastOnce = true;

        return;

        void UpdateState(object? _, State state)
        {
            State = StateViewData.FromState<T>(state, _timeProvider.GetUtcNow(), LoadStoreWithStateHandler);
            InvokeAsync(StateHasChanged);
        }

        void InvokeStateLoadedSuccessfully(object? _, State state)
        {
            if (state is SuccessState<T> successState)
            {
                StateLoadedSuccessfully?.Invoke(this, successState.LoadedIn);
            }
        }
    }

    /// <summary>
    /// Gets the current state view data if it is of the specified type.
    /// </summary>
    /// <param name="currentViewData">The current view data.</param>
    /// <typeparam name="TViewData">The view data type.</typeparam>
    /// <returns></returns>
    public bool TryGetCurrentState<TViewData>([NotNullWhen(true)] out TViewData currentViewData) where TViewData : StateViewData
    {
        if (State is TViewData viewData)
        {
            currentViewData = viewData;
            return true;
        }

        currentViewData = null!;
        return false;
    }

}